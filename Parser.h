/****************************************Copyright (c)****************************************************
**
**                                       D.H. InfoTech
**
**--------------File Info---------------------------------------------------------------------------------
** File name:                  KeyParser.h
** Latest Version:             V1.0.0
** Latest modified Date:       2016/3/2
** Modified by:                
** Descriptions:               
**
**--------------------------------------------------------------------------------------------------------
** Created by:                 Chen Honghao
** Created date:               2016/3/1
** Descriptions:               KeyParser class  [Generated by VP-UML, IGT1.0]
** 
*********************************************************************************************************/
#ifndef __KEYPARSER_H__
#define __KEYPARSER_H__


#if defined(_MSC_VER)
#pragma warning(disable: 4100)
#endif

class IParser;
class Object;
class JsonLoader;

#include "JsonLoader_p.h"


/**
 *  @class IParser
 *  @brief 解析器的基类，仅对需要访问JsonLoader保护操作的部分进行简单封装
 */
class IParser
{
public:
    /**
     * Constructor
     * @param[in]    loader 
     */
    IParser(JsonLoader* loader = NULL) : m_loader(loader)
    {

    }

    void error(int code, const QString& message) const;

    QVariant parseValue(ObjectContext& objectContext, int metaTypeHint = QMetaType::UnknownType) const;

    int parseArrayElementType(int propertyMetaTypeId, const QString& propertyMetaTypeName) const;

    QVariant parseArrayValue(const QVariantList& valueArray, int metaTypeHint = QMetaType::UnknownType) const;

    bool addTranslation(ObjectContext& objectContext) const;

    QVariant loadJsonFile(
        const QString& jsonFile,
        ObjectContext& parentContext, 
        const QString& parentKey
        ) const;

protected:
    bool parseObjectAndContents(
        ObjectContext* objectContext, 
        const QString& valueString, 
        QObject*& qObject, 
        const QMetaObject*& metaObject, 
        QString& contentName, 
        bool reportError = true
        ) const;

private:
    JsonLoader* m_loader;                   //!< 引用的JsonLoader对象，IParser需要访问其提供的一些数据处理操作
};

class ObjectCreator : public IParser
{
public:
    ObjectCreator(JsonLoader* loader, const QString& idKey) : IParser(loader), m_idKey(idKey)
    {

    }

    virtual bool parse(ObjectContext* objectContext) const;

protected:
    virtual int  parseObjectMetaType(ObjectContext* objectContext) const = 0;
    virtual bool isQObject(int metaType) const;
    /*! 
     * 在创建对象时解析.id关键字，从而保证一旦对象创建完毕即可在外部查找此对象而不必涉及属性依赖问题
     * @param[in]  objectContext
     * @return     bool
     */
    virtual bool parseIdKey(ObjectContext* objectContext, QObject* qObject) const;

protected:
    /*
     * @brief 创建对象时必须直接通过id属性来初始化对象名，方便其他对象引用，
     *        这里记录id属性的属性名
     */
    QString m_idKey;
};

class DefaultTypeObjectCreator : public ObjectCreator
{
public:
    DefaultTypeObjectCreator(
        JsonLoader* loader, 
        int metaType = QMetaType::UnknownType,
        const QString& idKey = ".id"
        ) : ObjectCreator(loader, idKey), m_defaultType(metaType)
    {

    }

protected:
    virtual int  parseObjectMetaType(ObjectContext* objectContext) const
    {
        if (objectContext->value().type() != QJsonValue::Object)
            return QMetaType::UnknownType;

        return m_defaultType;
    }

private:
    int m_defaultType;
};


class MetaTypeKeyObjectCreator : public ObjectCreator
{
public:
    MetaTypeKeyObjectCreator(
        JsonLoader* loader, 
        const QString& key = ".type", 
        const QString& idKey = ".id"
        ) : ObjectCreator(loader, idKey), m_key(key)
    {

    }

    QString key() const
    {
        return m_key;
    }

protected:
    virtual int  parseObjectMetaType(ObjectContext* objectContext) const;

private: 
    QString 		m_key;
};

class RefKeyObjectCreator : public ObjectCreator
{
public:
    RefKeyObjectCreator(
        JsonLoader* loader, 
        const QString& key = ".ref", 
        const QString& idKey = ".id"
        ) : ObjectCreator(loader, idKey), m_key(key)
    {

    }

    QString key() const
    {
        return m_key;
    }

protected:
    virtual bool parse(ObjectContext* objectContext) const;
    virtual int  parseObjectMetaType(ObjectContext* objectContext) const
    {
        // 不需要使用此函数
        return 0;
    }

private: 
    QString 		m_key;
};

class ParentPropertyObjectCreator : public ObjectCreator
{
public:
    ParentPropertyObjectCreator(
        JsonLoader* loader, 
        const QString& idKey = ".id"
        ) : ObjectCreator(loader, idKey)
    {

    }

protected:
    virtual int  parseObjectMetaType(ObjectContext* objectContext) const;
};


class KeyParser : public IParser
{
public: 
    /**
     * Constructor
     * @param[in]    loader 
     * @param[in]    key    
     */
    KeyParser(JsonLoader* loader, const QString& key) : IParser(loader), m_key(key)
    {

    }

    QString key() const
    {
        return m_key;
    }

    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const;

    /**
     * 
     * @param[in]    key	
     * @return       操作成功返回true
     */
    virtual bool matches(const QString& key) const;

private: 
    QString 		m_key;
    JsonLoader*     m_loader;
};

class IdKeyParser : public KeyParser
{
public:
    IdKeyParser(JsonLoader* loader, const QString& key = ".id") : KeyParser(loader, key)
    {

    }

protected:
    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;
};

class ObjectsKeyParser : public KeyParser
{
public:
    ObjectsKeyParser(JsonLoader* loader, const QString& key = ".objects") : KeyParser(loader, key)
    {

    }

protected:
    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;
};

class ConnectionsKeyParser : public KeyParser
{
public:
    ConnectionsKeyParser(JsonLoader* loader, const QString& key = ".connections") : KeyParser(loader, key)
    {

    }

protected:
    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;
};

class QParentKeyParser : public KeyParser
{
public:
    QParentKeyParser(JsonLoader* loader, const QString& key = ".qparent") : KeyParser(loader, key)
    {

    }

protected:
    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;
};

class QChildrenKeyParser : public KeyParser
{
public:
    QChildrenKeyParser(JsonLoader* loader, const QString& key = ".qchildren") : KeyParser(loader, key)
    {

    }

protected:
    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;
};

/**
 *  @class ChildPropertyKeyParser
 *  @brief 用于解析当前对象的属性，例如"myKey": "Hello"
 */
class PropertyKeyParser : public KeyParser
{
public:
    PropertyKeyParser(JsonLoader* loader);

protected:
    virtual bool matches(const QString& key) const;

    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;

    virtual bool parseObjectAndProperty(ObjectContext* objectContext, const QString& key, QObject*& qObject, QMetaProperty& property) const;
};

/**
 *  @class ChildPropertyKeyParser
 *  @brief 用于解析子对象的属性，例如"son.grandson.keyOfGrandson": "Hello"
 */
class ChildPropertyKeyParser : public PropertyKeyParser
{
public:
    ChildPropertyKeyParser(JsonLoader* loader);

protected:
    virtual bool matches(const QString& key) const;

    virtual bool parseObjectAndProperty(ObjectContext* objectContext, const QString& key, QObject*& qObject, QMetaProperty& property) const Q_DECL_OVERRIDE;
};

class MethodKeyParser : public KeyParser
{
public:
    MethodKeyParser(JsonLoader* loader) : KeyParser(loader, QString())
    {

    }

protected:
    virtual bool parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const Q_DECL_OVERRIDE;
};


class ValueParser : public IParser
{
public:
    ValueParser(JsonLoader* loader, int metaType) : IParser(loader), m_metaType(metaType)
    {

    }

    int metaType() const
    {
        return m_metaType;
    }

    virtual bool matches(int metaType) const
    {
        return m_metaType == metaType || m_metaType == 0;
    }

protected:
    int m_metaType;
};

class ArrayValueParser : public ValueParser
{
public:
    ArrayValueParser(JsonLoader* loader, int metaType) : ValueParser(loader, metaType)
    {

    }

    int elementMetaTypeId(const QString& elementTypeName) const
    {
        //int elementMetaTypeId = QMetaType::type(listMetaTypeName.toLatin1().constData());
        QString typeName = elementTypeName;
        if (typeName.endsWith(QLatin1Char('*')))
            typeName.chop(1);

        return GET_METATYPE_ID_METHOD(typeName);
    }

    virtual int parseArrayElementType(int propertyMetaTypeId, const QString& propertyMetaTypeName) const = 0;
    virtual QVariant parseValue(const QVariantList& valueArray) const = 0;
};

/**
 *  @class GenericContainerValueParser
 *  @brief 通用容器类数组，该容器必须支持push_back操作，例如QList/QVector/std::list等
 */
template<class T, class Container>
class GenericContainerValueParser : public ArrayValueParser
{
public:
    GenericContainerValueParser(JsonLoader* loader, int metaType, const QRegExp& typeNamePattern) : 
        ArrayValueParser(loader, metaType), m_typeNamePattern(typeNamePattern)
    {

    }

    QRegExp typeNamePattern() const
    {
        return m_typeNamePattern;
    }

    void setTypeNamePattern(const QRegExp& typeNamePattern)
    {
        m_typeNamePattern = typeNamePattern;
    }

    virtual int parseArrayElementType(int propertyMetaTypeId, const QString& propertyMetaTypeName) const
    {
        // 注意此处不支持多线程 [5/6/2016 CHENHONGHAO]
        int pos = m_typeNamePattern.indexIn(propertyMetaTypeName);
        if (pos < 0)
            return QMetaType::UnknownType;

        QString listMetaTypeName = m_typeNamePattern.cap(1);
        int elementMetaTypeId = ArrayValueParser::elementMetaTypeId(listMetaTypeName);
        if (elementMetaTypeId != QMetaType::UnknownType)
            return elementMetaTypeId;

        Q_UNUSED(propertyMetaTypeId);

        return m_metaType;
    }

    virtual QVariant parseValue(const QVariantList& valueArray) const
    {
        return format(valueArray);
    }

protected:
    QVariant format(const QVariantList& valueArray) const
    {
        Container result;

        QVariantList::const_iterator iter = valueArray.constBegin();
        QVariantList::const_iterator cend = valueArray.constEnd();
        for (iter; iter != cend; ++iter)
        {
            result.push_back((*iter).value<T>());
        }

        return QVariant::fromValue< Container >(result);
    }

private:
    QRegExp m_typeNamePattern;              //!< 使用正则表达式来判定数组元素类型
};

#define DEFINE_GENERIC_CONTAINER_VALUE_PARSER_CLASS(_class_name, _container_type)                       \
template<class T>                                                                                       \
class _class_name : public GenericContainerValueParser<T, _container_type<T> >                          \
{                                                                                                       \
public:                                                                                                 \
    _class_name(                                                                                        \
        JsonLoader* loader,                                                                             \
        int metaType = 0,                                                                               \
        const QRegExp& typeNamePattern =                                                                \
        QRegExp(#_container_type "<(.+)>", Qt::CaseSensitive, QRegExp::RegExp)                          \
        )                                                                                               \
        : GenericContainerValueParser<T, _container_type<T> >(loader, metaType, typeNamePattern) {}     \
};

DEFINE_GENERIC_CONTAINER_VALUE_PARSER_CLASS(GenericListValueParser,   QList)
DEFINE_GENERIC_CONTAINER_VALUE_PARSER_CLASS(GenericVectorValueParser, QVector)


class StringValueParser : public ValueParser
{
public:
    enum 
    {
        AllStrings = 0,
        ObjectNameString = -1,
        EnumNameString = -2,
        PropertyNameString = -3,
        MethodNameString = -4,
        SignalNameString = MethodNameString,
        SlotNameString = MethodNameString
    };

public:
    StringValueParser(JsonLoader* loader, int metaType = AllStrings) : ValueParser(loader, metaType)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        return ValueParser::matches(metaType);
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class TranslatedStringValueParser : public StringValueParser
{
public:
    TranslatedStringValueParser(JsonLoader* loader) : StringValueParser(loader, QMetaType::QString)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        if (tags.isEmpty() || tags.contains("tr"))
            return ValueParser::matches(metaType);

        return false;
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;

    static QString translate(const QString& string);
};

class ObjectNameStringValueParser : public StringValueParser
{
public:
    ObjectNameStringValueParser(JsonLoader* loader) : StringValueParser(loader, QMetaType::QObjectStar)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        return true;
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class ObjectContentStringValueParser : public StringValueParser
{
public:
    ObjectContentStringValueParser(JsonLoader * loader, int metaType);
};

class EnumNameStringValueParser : public ObjectContentStringValueParser
{
public:
    EnumNameStringValueParser(JsonLoader * loader) : ObjectContentStringValueParser(loader, QMetaType::Int)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        // 在解析key时如果遇到枚举，已经将其标识为特殊metaType
        return metaType == QMetaType::Int || metaType == QMetaType::UInt || metaType == EnumNameString;
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class PropertyNameStringValueParser : public ObjectContentStringValueParser
{
public:
    PropertyNameStringValueParser(JsonLoader * loader) : ObjectContentStringValueParser(loader, PropertyNameString)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        // 考虑到属性的binding，属性字段有可能和任何类型匹配
        return true;
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class MethodNameStringValueParser : public ObjectContentStringValueParser
{
public:
    MethodNameStringValueParser(JsonLoader * loader) : ObjectContentStringValueParser(loader, MethodNameString)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        // 考虑到属性的binding，属性字段有可能和任何类型匹配
        return StringValueParser::matches(metaType, tags);
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class PixmapStringValueParser : public StringValueParser
{
public:
    PixmapStringValueParser(JsonLoader * loader) : StringValueParser(loader, QMetaType::QPixmap)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        return metaType == QMetaType::QPixmap || metaType == QMetaType::QIcon;
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class SizeStringValueParser : public StringValueParser
{
public:
    SizeStringValueParser(JsonLoader * loader) : StringValueParser(loader, QMetaType::QSize)
    {

    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class RectStringValueParser : public StringValueParser
{
public:
    RectStringValueParser(JsonLoader * loader) : StringValueParser(loader, QMetaType::QRect)
    {

    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

class DateTimeStringValueParser : public StringValueParser
{
public:
    DateTimeStringValueParser(JsonLoader * loader) : StringValueParser(loader, QMetaType::QDateTime)
    {

    }

    virtual bool matches(int metaType, const QStringList& tags) const
    {
        return 
            metaType == QMetaType::QDateTime || 
            metaType == QMetaType::QDate ||
            metaType == QMetaType::QTime;
    }

    virtual QVariant parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const;
};

#if defined(_MSC_VER)
#pragma warning(default: 4100)
#endif
#endif
/*********************************************************************************************************
** End of file
*********************************************************************************************************/
