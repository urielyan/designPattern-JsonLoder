/****************************************Copyright (c)****************************************************
**
**                                       D.H. InfoTech
**
**--------------File Info---------------------------------------------------------------------------------
** File name:                  KeyParser.cpp
** Latest Version:             V1.0.0
** Latest modified Date:       2016/3/2
** Modified by:                
** Descriptions:               
**
**--------------------------------------------------------------------------------------------------------
** Created by:                 Chen Honghao
** Created date:               2016/3/1
** Descriptions:               KeyParser class  [Generated by VP-UML, IGT1.0]
** 
*********************************************************************************************************/
#if defined(_MSC_VER) && (_MSC_VER >= 1600)  
# pragma execution_character_set("utf-8")  
#endif

#include "Object.h"
#include "Parser.h"
#include "JsonLoader.h"

#include <QObject>
#include <QCoreApplication>
#include <QtWidgets/QWidget>
#include <QJsonValue>
#include <QMetaType>
#include <QMetaObject>
#include <QMetaProperty>

#include <QtGui/QPixmap>
#include <QDateTime>

#include <QDebug>


void IParser::error( int code, const QString& message ) const
{
    if (!m_loader) 
    {
        qDebug() << "Parser error [" << code << "]: " << message;
        return;
    }

    emit m_loader->error(code, message);
}

QVariant IParser::parseValue( ObjectContext& objectContext, int metaTypeHint /*= QMetaType::UnknownType*/ ) const
{
    if (!m_loader) {
        return QVariant();
    }

    return m_loader->parseValue(objectContext, metaTypeHint);
}

int IParser::parseArrayElementType( int propertyMetaTypeId, const QString& propertyMetaTypeName ) const
{
    if (!m_loader) {
        return QMetaType::UnknownType;
    }

    return m_loader->parseArrayElementType(propertyMetaTypeId, propertyMetaTypeName);
}

QVariant IParser::parseArrayValue( const QVariantList& valueArray, int metaTypeHint /*= QMetaType::UnknownType*/ ) const
{
    if (!m_loader) {
        return QVariant();
    }

    return m_loader->parseArrayValue(valueArray, metaTypeHint);
}

bool IParser::addTranslation( ObjectContext& objectContext ) const
{
    if (!m_loader) {
        return false;
    }

    return m_loader->addTranslation(objectContext);
}

QVariant IParser::loadJsonFile(const QString& jsonFile, ObjectContext& parentContext, const QString& parentKey) const
{
    if (!m_loader) {
        return QVariant();
    }

    return m_loader->load(jsonFile, parentContext, parentKey, QList<ObjectContext*>(), QList<ObjectContext*>());
}

bool IParser::parseObjectAndContents( 
    ObjectContext* objectContext, 
    const QString& valueString, 
    QObject*& qObject, 
    const QMetaObject*& metaObject, 
    QString& contentName, 
    bool reportError /*= true*/ 
    ) const
{
    QStringList contents = valueString.split(QChar('.'), QString::KeepEmptyParts);
    int levelCount = contents.size();
    if (levelCount <= 1)
    {
        if (reportError)
            error(JsonLoader::StringValueParserError, QString("Failed to split string of 'a.b' format: ") + valueString);
        return false;
    }
    
    contentName = contents[levelCount - 1];
    // 当传入的qObject初始值不为NULL时，说明在调用此函数之前已经知道了当前的qObject，
    // 通常说明该qObject即为当前对象自身，相当于this [6/15/2016 CHENHONGHAO] 
    if (qObject == NULL)
    {
        QString objectName = contents[0];
        if (objectName.isEmpty())
        {
            if (reportError)
                error(JsonLoader::StringValueParserError, QString("No class/object name in string:") + valueString);
            return false;
        }
        else if (objectName.at(0).isLower())
        {
            Object* object = objectContext->findUpwards(objectName);
            qObject = object ? object->qObject() : NULL;
            metaObject = qObject ? qObject->metaObject() : NULL;
        }
        else
        {
            int metaType = QMetaType::UnknownType;
            while ((metaType = GET_METATYPE_ID_METHOD(objectName)) == QMetaType::UnknownType || 
                (metaObject = GET_METAOBJECT_METHOD(metaType)) == NULL)
            {
                if (objectName.endsWith(QLatin1Char('*')))
                    break;

                objectName.append(QLatin1Char('*'));
            }

            qObject = NULL;

            if (metaObject == NULL)
            {
                if (reportError)
                    error(JsonLoader::StringValueParserError, QString("Unknown class:") + objectName);
                return false;
            }
        }

        contents.pop_front();
    }
    else
    {
        metaObject = qObject->metaObject();
    }
    contents.pop_back();

    // 中间阶段必须为父对象的子属性，且子属性的值必须为QObject*
    while (qObject && !contents.isEmpty())
    {
        QString propertyName = contents.front();
        contents.pop_front();

        QVariant property = qObject->property(propertyName.toLatin1().constData());
        qObject = property.value<QObject*>();
    }

    return true;
}


bool ObjectCreator::parse( ObjectContext* objectContext ) const
{
    if (objectContext == NULL) {
        return false;
    } else if (objectContext->qObject() != NULL) {
        return true;
    }

    int metaType = parseObjectMetaType(objectContext);
    QObject* qObject = NULL;
    if (metaType != QMetaType::UnknownType)
    {
#if 1
        // 实际上不是QObject的对象，通常不会以{}的形式书写，而是以字符串或者常量的形式 [5/6/2016 CHH513]
        if (!isQObject(metaType))
        {
            Q_ASSERT(objectContext->qObject() == NULL);
            return true;
        }
#else
        Q_ASSERT_X(isQObject(metaType), "ObjectCreator::parse", "ObjectCreator can ONLY create QObjects.");
#endif

        void* ptr = CREATE_METATYPE_OBJECT_METHOD(metaType);
        qObject = reinterpret_cast<QObject*>(ptr);
        objectContext->setQObject(qObject);
    }

    if (qObject)
        return parseIdKey(objectContext, qObject);

    return false;
}

bool ObjectCreator::isQObject( int metaType ) const
{
#if ENABLE_CUSTOM_OBJECT_FACTORY
    // 默认使用自定义对象工厂创建的对象全部是QObject
    if (metaType >= ObjectType::ObjectTypeIdBase)
        return true;
#endif

    if (metaType < QMetaType::User) {
        return metaType == QMetaType::QObjectStar;
    }

    // FIXME: 此处重复获取了部分信息，考虑优化
    const char* metaTypeString = QMetaType::typeName(metaType);
    if (metaTypeString == NULL) {
        // 无法识别的类型，默认返回false
        return false;
    }

    int pointerMetaType = metaType;
    QLatin1String metaTypeName(metaTypeString);
    int metaTypeNameLength = metaTypeName.size();
    if (metaTypeString[metaTypeNameLength - 1] != '*') 
    {
        pointerMetaType = metaType - 1;

        const char* guessedPointerMetaTypeString = QMetaType::typeName(pointerMetaType);
        QLatin1String guessedPointerMetaTypeName(guessedPointerMetaTypeString);
        bool bingo = false;
        if (guessedPointerMetaTypeName.size() == metaTypeNameLength + 1 && 
            guessedPointerMetaTypeString[metaTypeNameLength] == '*')
        {
            const char* a = metaTypeString;
            const char* b = guessedPointerMetaTypeString;
            bingo = true;
            while (metaTypeNameLength--)
            {
                if (*a++ != *b++) {
                    bingo = false;
                    break;
                }
            }
        }

        if (!bingo)
        {
            QString pointerMetaTypeName = QString(metaTypeName).append(QLatin1Char('*'));
            pointerMetaType = QMetaType::type(pointerMetaTypeName.toLatin1().constData());
        }
    }
        
    const QMetaObject* metaObject = GET_METAOBJECT_METHOD(pointerMetaType);
    if (metaObject == NULL)
    {
        // 重复注册的类，其对应的MetaObject可能与自身的metaType不对应
        QString pointerMetaTypeName = QString(metaTypeName).append(QLatin1Char('*'));
        pointerMetaType = QMetaType::type(pointerMetaTypeName.toLatin1().constData());
        metaObject = GET_METAOBJECT_METHOD(pointerMetaType);
    }
    if (metaObject != NULL && metaObject->propertyCount() >= 1)
    {
        // 从QObject继承的对象，至少包含objectName属性，
        // 因此如果某个对象没有属性，则不是QObject的子类，也就不需要创建对象
        // 此类对象多为数据，例如QString，QRect，QFont等
        return true;
    }

    return false;
}

bool ObjectCreator::parseIdKey(ObjectContext* objectContext, QObject* qObject) const
{
    KeyObjectContextMapConstIter keyIter = objectContext->constChild(m_idKey);
    if (keyIter == objectContext->constChildEnd()) 
    {
        // 允许匿名对象，不要报错
        return true;
    }
    const ObjectContextList& ids = keyIter->second;

    if (ids.size() != 1) 
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Number of 'id' keys can not be %1").arg(ids.size())
            );
        return false;
    }

    QJsonValue& idValue = ids.front()->value();
    if (idValue.type() != QJsonValue::String)
    {
        error(
            JsonLoader::KeyParserError, 
            QString("The 'id' key must be a String")
            );
        return false;
    }

    QString  objectName = idValue.toString();
#if defined(_DEBUG) && 0
    // 此处仅用于调试 [3/18/2016 CHENHONGHAO]
    if (objectName == "nextCurveButton")
    {
        int breakPoint = 0;
    }
#endif
#if ENABLE_LEGACY_KEYWORDS
    // 新版本的.id关键字由于加入了.前缀，已经不可能与属性名重复 [5/6/2016 CHENHONGHAO]
    // 有部分类使用id作为普通属性名，这里必须进行处理 [3/16/2016 CHENHONGHAO]
    const QMetaObject* metaObject = qObject->metaObject();
    int idPropertyIndex = -1;
    if (metaObject && (idPropertyIndex = metaObject->indexOfProperty(m_idKey.toLatin1().constData())) >= 0)
    {
        QMetaProperty metaProperty = metaObject->property(idPropertyIndex);
        metaProperty.write(qObject, objectName);
    }
#endif
#if 1
    objectContext->removeChild(keyIter);
#else
    keyIter->first.clear();
#endif
    return objectContext->setId(objectName);
}

int MetaTypeKeyObjectCreator::parseObjectMetaType( ObjectContext* objectContext) const
{
    int type = QMetaType::UnknownType;
    QString metaTypeName;

    KeyObjectContextMapConstIter keyIter = objectContext->constChild(m_key);
    if (keyIter == objectContext->constChildEnd()) 
    {
        return false;
    }
    const ObjectContextList& types = keyIter->second;
    if (types.size() != 1)
    {
        return false;
    }
    ObjectContext* context = types.front();
    Q_ASSERT(context);
    metaTypeName = context->value().toString();
    type = GET_METATYPE_ID_METHOD(metaTypeName);
#if 1
    if (!objectContext->removeChild(keyIter))
    {
        Q_ASSERT_X(0, "objectContext->removeChild", "Failed to remove parsed metaType property.");
    }
#else
    keyIter->first.clear();
#endif

    return type;
}

bool RefKeyObjectCreator::parse(ObjectContext* objectContext) const
{
    if (objectContext == NULL) {
        return false;
    } else if (objectContext->qObject() != NULL) {
        return true;
    }

    KeyObjectContextMapConstIter keyIter = objectContext->constChild(m_key);
    if (keyIter == objectContext->constChildEnd()) 
    {
        return false;
    }
    const ObjectContextList& ids = keyIter->second;

    if (ids.size() != 1) 
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Number of ref-object names can not be %1").arg(ids.size())
            );
        return false;
    }

    QJsonValue& idValue = ids.front()->value();
    if (idValue.type() != QJsonValue::String)
    {
        error(
            JsonLoader::KeyParserError, 
            QString("The '.ref' key must be a String of an existing Object in current version.")
            );
        return false;
    }

    QString  objectName = idValue.toString();
    objectContext->removeChild(keyIter);
    if (idValue.type() == QJsonValue::String && objectName.endsWith(QLatin1String(".json")))
    {
        QString nestedJsonFilePath = objectName;
        ObjectContext* parentContext = objectContext->parent();

        QVariant nestedLoadedObjects = loadJsonFile(
            nestedJsonFilePath, 
            parentContext ? *parentContext : ObjectContext(), 
            objectContext->parentKey()
            );
        QObject* qObject = nestedLoadedObjects.value<QObject*>();
        if (!qObject)
        {
            error(
                JsonLoader::KeyParserError, 
                QString("JSON file referencing failed: ") + nestedJsonFilePath
                );
        }
        objectContext->setQObject(qObject);
    }
    else
    {
        Object* object = objectContext->findUpwards(objectName);
        if (object == NULL)
        {
            error(
                JsonLoader::KeyParserError, 
                QString("Can not find referenced object: ") + objectName
                );
            return false;
        }
        objectContext->setQObject(object->qObject());

        // TODO: 不使用硬编码来指定.copy关键字
        KeyObjectContextMapConstIter keyIter = objectContext->constChild(QStringLiteral(".copy"));
        if (keyIter != objectContext->constChildEnd()) 
        {
            QJsonValue& isCopy = keyIter->second.front()->value();
            if (isCopy.toBool())
            {
                QObject* srcObject = object->qObject();
                QObject* newObject = NULL;
                const QMetaObject* srcMetaObject = srcObject ? srcObject->metaObject() : NULL;
                if (srcMetaObject)
                {
                    const char* srcClassName = srcMetaObject->className();
                    int srcClassId = QMetaType::type(srcClassName);
                    if (srcClassId != QMetaType::UnknownType)
                    {
                        // 此处只能使用QMetaType而不能使用自定义的对象工厂，因为该工厂不支持拷贝构造
                        newObject = (QObject*)QMetaType::create(srcClassId, srcObject);
                    }
                }

                if (newObject)
                {
                    objectContext->setQObject(newObject);
                }
                else
                {
                    error(
                        JsonLoader::KeyParserError, 
                        QString("Failed to copy referenced object: ") + objectName + ", fallback to source object."
                        );
                }

                objectContext->removeChild(keyIter);
            }
        }
        
    }

    QObject* qObject = objectContext->qObject();
    if (qObject)
        return parseIdKey(objectContext, qObject);

    return false;
}

int ParentPropertyObjectCreator::parseObjectMetaType( ObjectContext* objectContext) const
{
    // “使用父节点的属性类型来创建新对象”这种方式应仅使用于JSON值确实为一个对象节点的场景 [3/16/2016 CHENHONGHAO]
    if (objectContext->value().type() != QJsonValue::Object) {
        return QMetaType::UnknownType;
    }

    // 由于JSON数组已经被拆分为独立对象，这里应该在获取类型时同样展开QList封装
    KeyObjectContextMapConstIter iter = objectContext->findInParent();
    if (iter->second.count() > 1)
    {
        // 如果同样的key在parent下有多个JSON对象，则说明为数组
        // 注意由于载入JSON时在队列的头部插入了一个“数组JSON”对象，因此即使数组只有一个元素，此时count也为2
        QMetaProperty parentMetaProperty = objectContext->parentProperty();
        int parentPropertyMetaTypeId = parentMetaProperty.userType();
        QString parentPropertyMetaTypeName = QString::fromLatin1(parentMetaProperty.typeName());

        int arrayElementTypeId = parseArrayElementType(parentPropertyMetaTypeId, parentPropertyMetaTypeName);
        return arrayElementTypeId;
    }

    // 考虑到适应能力有限，parentPropertyType不再支持展开容器类，
    // 因此如果为数组，不能再调用这个函数，需要在JsonLoader对象的帮助下手动解析数组元素类型类型 [5/7/2016 CHH513]
    return objectContext->parentPropertyType();
}


/**
 * 
 * @param[in]    key	
 * @return       操作成功返回true
 */
bool KeyParser::matches(const QString& key) const
{
    return m_key.isEmpty() || m_key == key;
}

bool KeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    Q_ASSERT_X(false, "KeyParser::parse", "Pure virtual function called.");
    return false;
}

bool IdKeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    const ObjectContextList& ids = keyIter->second;

    if (ids.size() != 1) 
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Number of 'id' keys can not be %1").arg(ids.size())
            );
        return false;
    }

    QJsonValue& idValue = ids.front()->value();
    if (idValue.type() != QJsonValue::String)
    {
        error(
            JsonLoader::KeyParserError, 
            QString("The 'id' key must be a String")
            );
        return false;
    }

    if (objectContext)
    {
        QString  objectName = idValue.toString();
        return objectContext->setId(objectName);
    }

    return false;
}


bool ObjectsKeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    // Nothing to do
    return true;
}


bool ConnectionsKeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    return false;
}

bool QParentKeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    const ObjectContextList& parents = keyIter->second;
    if (parents.size() != 1) 
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Number of 'qparent' keys can not be %1").arg(parents.size())
            );
        return false;
    }

    QVariant parentVariant = parseValue(*parents.front(), QMetaType::QObjectStar);
    if ((int)parentVariant.type() != QMetaType::QObjectStar)
    {
        error(
            JsonLoader::KeyParserError, 
            QString("The 'qparent' key must be a QObject*")
            );
        return false;
    }

    if (objectContext && objectContext->qObject())
    {
        QObject* parent  = parentVariant.value<QObject*>();
        QObject* qObject = objectContext->qObject();
        if (qObject && !parent) {
            qObject->setParent(parent);
            return true;
        }

        bool parentIsWidget = parent->isWidgetType();
        bool objectIsWidget = qObject->isWidgetType();
        if (parentIsWidget && objectIsWidget) {
            ((QWidget*)qObject)->setParent((QWidget*)parent);
        } else if (!parentIsWidget && !objectIsWidget) {
            qObject->setParent(parent);
        } 
        else 
        {
            error(
                JsonLoader::KeyParserError, 
                QString("Hierarchy relationship mismatch: objectIsWidget=%1, parentIsWidget=%2")
                .arg(objectIsWidget)
                .arg(parentIsWidget)
                );
            return false;
        }
    }

    return false;
}

bool QChildrenKeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    bool allOk = true;

    const ObjectContextList& children = keyIter->second;
    QObject* qObject = objectContext->qObject();
    if (qObject == NULL) {
        return false;
    }

    ObjectContextList::const_iterator iter = children.constBegin();
    ObjectContextList::const_iterator cend = children.constEnd();

    if (iter != cend)
    {
        // 子对象数组的首个元素为数组本身 [3/18/2016 CHENHONGHAO]
        if ((*iter)->value().type() == QJsonValue::Array)
        {
            ++iter;
        }
    }

    for (iter; iter != cend; ++iter)
    {
        QVariant childVariant = parseValue(*(*iter), QMetaType::QObjectStar);
        if ((int)childVariant.type() != QMetaType::QObjectStar)
        {
            error(
                JsonLoader::KeyParserError, 
                QString("The 'qchildren' key must be a QObject*")
                );
            allOk = false;
            continue;
        }

        // 由于类型不识别等问题，子对象不一定已经被成功创建 [3/21/2016 CHENHONGHAO]
        QObject* child  = childVariant.value<QObject*>();
        if (!child)
        {
            error(
                JsonLoader::KeyParserError, 
                "QChildrenKeyParser: Each child of QObject-child-type should have been created already."
                );
            allOk = false;
            continue;
        }

        bool childIsWidget = child->isWidgetType();
        bool objectIsWidget = qObject->isWidgetType();
        if (childIsWidget && objectIsWidget) {
            ((QWidget*)child)->setParent((QWidget*)qObject);
        } else if (!childIsWidget && !objectIsWidget) {
            child->setParent(qObject);
        } 
        else 
        {
            error(
                JsonLoader::KeyParserError, 
                QString("Hierarchy relationship mismatch: objectIsWidget=%1, childIsWidget=%2")
                .arg(objectIsWidget)
                .arg(childIsWidget)
                );
            allOk = false;
        }
    }

    return allOk;
}


PropertyKeyParser::PropertyKeyParser(JsonLoader* loader) : KeyParser(loader, QString())
{
}

bool PropertyKeyParser::parseObjectAndProperty(ObjectContext* objectContext, const QString& key, QObject*& qObject, QMetaProperty& property) const
{
    qObject = objectContext->qObject();
    if (qObject == NULL)
        return false;

    property = objectContext->property(key);

    return true;
}

bool PropertyKeyParser::matches(const QString& key) const
{
    return key.at(0).unicode() != '.';
}

bool PropertyKeyParser::parse(ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter) const
{
    const QString&           key    = keyIter->first;
    const ObjectContextList& values = keyIter->second;
    QObject* qObject = NULL;
    QMetaProperty qProperty;

#if defined(_DEBUG) && 0
    if (key == "lineEdit")
    {
        int id5 = QMetaType::type("QLineEdit*");
        int breakpoint = 0;
    }
#endif

    parseObjectAndProperty(objectContext, key, qObject, qProperty);
    if (!qObject || !qProperty.isValid())
    {
        // 不允许报错，因为可能只是在尝试
        return false;
    }

    QVariant propertyVariant;
    
    int  propertyMetaType = QMetaType::UnknownType;
    bool propertyIsEnum   = qProperty.isEnumType();
    if (propertyIsEnum) 
    {
        // 实际上考虑到int类型的属性使用枚举赋值的情况，
        // EnumNameStringValueParser使用QMetaType::Int而不是StringValueParser::EnumNameString作为key 
        // 这里为了保证效率，保证使用hash定位StringValueParser时能一次到位，
        // 需要将metaTypeHint设置为QMetaType::Int [3/23/2016 CHENHONGHAO]
        propertyMetaType = QMetaType::Int;
        //propertyMetaType = StringValueParser::EnumNameString;
    } else {
        propertyMetaType = objectContext->propertyType(qProperty);
    }

    // 空的Value集合是不会构成一个Key的，一定是有代码在解析过程中将Value移除了
    Q_ASSERT_X(!values.isEmpty(), "PropertyKeyParser::parse", "Property value list can NOT be empty.");
    // 数组Key的首个元素是特殊情况，为了证明其为数组并在极端情况下获取数组的全部原始QJsonValue [3/18/2016 CHENHONGHAO]
    ObjectContext& firstValue = *values.front();
    if (firstValue.value().type() == QJsonValue::Array)
    {
        bool isStringList = false;
        // 首先解析数组元素类型
        int listMetaType = QMetaType::UnknownType;
        int     qPropertyType = qProperty.userType();
        QString qPropertyName = qProperty.typeName();
        // 此处仅对QStringList进行特殊处理，因为它是QMetaType原生支持的类型
        if (qPropertyType == QMetaType::QStringList) 
        {
            listMetaType = QMetaType::QString;
            isStringList = true;
        } 
        else if (qPropertyType == QMetaType::QVariantList)
        {
            listMetaType = QMetaType::QVariant;
        }
        else 
        {
            listMetaType = parseArrayElementType(qPropertyType, qPropertyName);
        }
        if (listMetaType == QMetaType::UnknownType)
        {
            error(
                JsonLoader::KeyParserError, 
                QString("Unrecognized list property type: %1").arg(qPropertyName)
                );
            //return false;
        }

        // 排除首个元素，目前不需要使用其中的QJsonArray值
        // 然后逐一解析数组元素的值
        QVariantList arrayVariant;
        ObjectContextList::const_iterator iter = ++values.constBegin();
        ObjectContextList::const_iterator cend = values.constEnd();
        for (; iter != cend; ++iter)
        {
            QVariant valueVariant = parseValue(*(*iter), listMetaType);
            int valueVariantType = valueVariant.type();
            if (valueVariantType != listMetaType && 
                valueVariantType != QMetaType::QObjectStar && 
                listMetaType != QMetaType::UnknownType &&
                listMetaType != QMetaType::QVariant)
            {
                // 如果返回的数据类型不匹配，尝试转换，通过这种方法可以实现double->int等标准转换
                if (!valueVariant.convert(listMetaType))
                {
                    error(
                        JsonLoader::KeyParserError, 
                        QString("Array item type mismatch: ArrayType:%1, ItemType:%2")
                        .arg(qPropertyName)
                        .arg(GET_METATYPE_NAME_METHOD(valueVariantType))
                        );
                    return false;
                }
            }

            arrayVariant.push_back(valueVariant);
        }

        // 然后将分离的数组元素值合并至数组
        propertyVariant = parseArrayValue(arrayVariant, listMetaType);
        if (!propertyVariant.isValid())
        {
            error(
                JsonLoader::KeyParserError,
                QString("Cannot parse array [%1] of metaType:%2,"
                "you may need to register a custom ArrayValueParser.")
                .arg(qPropertyName)
                .arg(listMetaType)
                );
            return false;
        }

        // 此处对QStringList进行特殊处理，原因同上
        if (isStringList)
        {
            QStringList list = propertyVariant.value< QList<QString> >();
            propertyVariant = QVariant::fromValue< QStringList >(list);
        }
    }
    else
    {
        propertyVariant = parseValue(firstValue, propertyMetaType);
        if (!propertyVariant.isValid())
        {
            // 已经在JsonLoader中报错
            return false;
        }

        int propertyVariantType = propertyVariant.type();
        if (propertyVariantType != propertyMetaType)
        {
            if (propertyVariant.canConvert<PropertyContext>())
            {
                PropertyContext targetPropertyContext = propertyVariant.value<PropertyContext>();

                PropertyConnection* connection = targetPropertyContext.addObserver(qObject, qProperty);
                if (!connection || !connection->isConnected())
                {
                    // 属性的绑定，需要同时绑定属性的notify信号
                    error(
                        JsonLoader::UnsupportedFeature, 
                        QString(
                            "Failed to bind property: %1 -> %2, "
                            "the property value will be copied only once, and no order is guaranteed.")
                        .arg(targetPropertyContext.metaProperty().name())
                        .arg(qProperty.name())
                        );
                    //return false;
                }

                return true;
            }
            else if (propertyVariantType == QMetaType::QString && propertyIsEnum)
            {
                // 枚举类型可以在QMetaProperty::write中将字符串转换为整数 [3/24/2016 CHENHONGHAO]
            }
            else if (propertyVariantType != QMetaType::QObjectStar)
            {
                if (propertyMetaType == QMetaType::QVariant)
                {
                    // 如果目标类型（例如属性类型）本身就是QVariant，那么不需要处理 [6/3/2016 CHENHONGHAO]
                }
                // 如果返回的数据类型不匹配，尝试转换，通过这种方法可以实现double->int等标准转换
                else if (!propertyVariant.convert(propertyMetaType))
                {
                    error(
                        JsonLoader::KeyParserError, 
                        QString("Property type mismatch: Object=%1, Key=%2, Value=%3")
                        .arg(objectContext->toString())
                        .arg(key)
                        .arg(propertyVariant.toString())
                        );
                    return false;
                }
            }
            else
            {
                // 返回的QObject的子类永远是以QObjectStar类型封装的，
                // 此处不需要解析到具体的QObject子类类型，
                // 因为QMetaProperty::write会使用reinterpret_cast进行指针类型的强制转换
                // FIXME: 此处应该严谨检查指针是否可以qobject_cast到指定类型 [3/18/2016 CHENHONGHAO]
            }
        }
    }

    if (!qProperty.write(qObject, propertyVariant))
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Failed to write property:%1 with value:%2, Object=%3.")
            .arg(key)
            .arg(propertyVariant.toString())
            .arg(objectContext->toString())
            );
        return false;
    }

    return true;
}

ChildPropertyKeyParser::ChildPropertyKeyParser(JsonLoader* loader) : PropertyKeyParser(loader)
{

}

bool ChildPropertyKeyParser::matches(const QString& key) const
{
    int indexOfDot = key.lastIndexOf(QLatin1Char('.'));
    // 最后一个.的位置必须大于0，因为如果等于0则有可能为JsonLoader的关键字 [6/15/2016 CHENHONGHAO]
    return indexOfDot > 0;
}

bool ChildPropertyKeyParser::parseObjectAndProperty(ObjectContext* objectContext, const QString& key, QObject*& qObject, QMetaProperty& property) const
{
    qObject = objectContext->qObject();
    if (qObject == NULL)
        return false;

    const QMetaObject* metaObject = NULL;
    QString childKeyShortName;
    bool ok = parseObjectAndContents(objectContext, key, qObject, metaObject, childKeyShortName, false);
    if (ok && qObject && !childKeyShortName.isEmpty())
    {
        const QMetaObject* metaObject = qObject->metaObject();
        int childPropertyIndex = metaObject->indexOfProperty(childKeyShortName.toLatin1().constData());
        property = metaObject->property(childPropertyIndex);

        return true;
    }

    return false;
}


bool MethodKeyParser::parse( ObjectContext* objectContext, KeyObjectContextMapConstIter keyIter ) const
{
    const QString&           key    = keyIter->first;
    const ObjectContextList& values = keyIter->second;
    QObject* qObject = objectContext->qObject();
    if (qObject == NULL) {
        return false;
    }
    else if (values.size() != 1)
    {
//         error(
//             JsonLoader::KeyParserError, 
//             QString("Number of 'signal-slot' connections can not be %1").arg(values.size())
//             );
        return false;
    }

    QList<QMetaMethod> thisMethods = objectContext->methods(key);
    if (thisMethods.isEmpty())
    {
        // 不允许报错，因为可能只是在尝试
        //error(JsonLoader::KeyParserError, QString("Failed to parse key:%1 as a method.").arg(key));
        return false;
    }

    QVariant targetMethodVariant = parseValue(*values.front(), StringValueParser::MethodNameString);
    MethodContext targetMethodContext = targetMethodVariant.value<MethodContext>();
    QObject* targetObject = targetMethodContext.qObject();
    QList<QMetaMethod> targetMethods = targetMethodContext.metaMethods();
    if (targetMethods.isEmpty() || !targetObject)
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Failed to parse value:%1 as a method.")
            .arg(values.front()->toString())
            );
        return false;
    }

    int connectionCount = MethodConnection::connect(qObject, thisMethods, targetObject, targetMethods);
    if (connectionCount <= 0)
    {
        error(
            JsonLoader::KeyParserError, 
            QString("Failed to connect signal-slot: %1 <-> %2")
            .arg(QLatin1String(thisMethods[0].methodSignature()))
            .arg(QLatin1String(targetMethods[0].methodSignature()))
            );
    }

    return true;
}

#if 0
int ArrayValueParser::elementMetaTypeId( const QString& elementTypeName ) const
{
    //int elementMetaTypeId = QMetaType::type(listMetaTypeName.toLatin1().constData());
    QString typeName = elementTypeName;
    if (typeName.endsWith(QLatin1Char('*')))
        typeName.chop(1);

    return GET_METATYPE_ID_METHOD(typeName);
}
#endif

QVariant StringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    return false;
}

QVariant TranslatedStringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    bool needTranslation = false;

    if (tags.contains("tr")) {
        needTranslation = true;
    }
    else
    {
        const QChar* chars  = valueString.constData();
        int    length = valueString.length();
        while (length--)
        {
            if ((*chars++).unicode() >= 128)
            {
                needTranslation = true;
                break;
            }
        }
    }

    if (!needTranslation) {
        return valueString;
    }

    if (!addTranslation(*objectContext)) {
        error(JsonLoader::TranslationError, QString("Failed to add translation: %1").arg(objectContext->toString()));
    }

    return translate(valueString);
}

QString TranslatedStringValueParser::translate( const QString& string )
{
    QByteArray raw = string.toUtf8();
    return qApp->translate("JsonLoader", raw.constData());
}

QVariant ObjectNameStringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    Object* target = NULL;
#if 0
    // 如果需要传入NULL，则直接使用JSON原生语法即可，例如："pointerProperty" : null,
    if (valueString.compare(QLatin1String("null"), Qt::CaseInsensitive) == 0)
    {
        return QVariant::fromValue<QObject*>(NULL);
    }
    else 
#endif
    if (objectContext && (target = objectContext->findUpwards(valueString)))
    {
        return QVariant::fromValue<QObject*>(target->qObject());
    }

    return QVariant();
}

ObjectContentStringValueParser::ObjectContentStringValueParser( JsonLoader * loader, int metaType ) : StringValueParser(loader, metaType)
{

}


QVariant EnumNameStringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    QObject* qObject = NULL;
    const QMetaObject* metaObject = NULL;
    QString contentName;
    int enumValue = 0;
    bool allOk = true;
    bool isUnregisteredEnum = false;

    QStringList parts = valueString.split(QChar('|'), QString::SkipEmptyParts);
    foreach (QString part, parts)
    {
        bool partOk = false;

        if (!parseObjectAndContents(objectContext, part, qObject, metaObject, contentName, false))
        {
//             error(JsonLoader::StringValueParserError, "Failed to parse enum value.");
//             return QVariant();
            // 按照未注册的枚举类型进行尝试 [3/24/2016 CHENHONGHAO]
            isUnregisteredEnum = true;
            break;
        }

        if (metaObject == NULL)
        {
//             error(
//                 JsonLoader::StringValueParserError, 
//                 QString("Failed to get metaObject for object from string: %1")
//                 .arg(valueString)
//                 );
//             return false;
            // 按照未注册的枚举类型进行尝试 [3/24/2016 CHENHONGHAO]
            isUnregisteredEnum = true;
            break;
        }

        int enumCount = metaObject->enumeratorCount();
        QByteArray keyData = contentName.toLatin1();
        const char* key = keyData.constData();
        for (int i = 0; i < enumCount; i++)
        {
            QMetaEnum enumerator = metaObject->enumerator(i);
            bool ok = false;
            int value = enumerator.keysToValue(key, &ok);
            if (ok)
            {
                enumValue |= value;
                partOk = true;
                break;
            }
        }

        if (!partOk)
        {
            error(
                JsonLoader::StringValueParserError, 
                QString("Failed to convert enum key:%1 to value.")
                .arg(contentName)
                );
            allOk = false;
        }
    }

    if (isUnregisteredEnum)
    {
        // 注意此处虽然方便复用QMetaType的默认处理手段，但有漏洞，可能会放过不是枚举的文本，例如对象名 [5/6/2016 CHENHONGHAO]
        QString enumString = valueString;
        if (enumString.contains(QLatin1Char('.')))
        {
            enumString.replace(QLatin1String("."), QLatin1String("::"), Qt::CaseSensitive);
            return enumString;
        }

        return QVariant();
    }

    if (!allOk)
    {
        error(
            JsonLoader::StringValueParserError, 
            QString("Failed to convert enums/flags string:%1 to value.")
            .arg(valueString)
            );
    }

    return enumValue;
}


QVariant PropertyNameStringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    QObject* qObject = NULL;
    const QMetaObject* metaObject = NULL;
    QString contentName;

    if (!parseObjectAndContents(objectContext, valueString, qObject, metaObject, contentName, false))
    {
        // PropertyNameStringValueParser使能了“全部匹配”功能，因此不能打印太多错误信息，避免误报
        //error(JsonLoader::StringValueParserError, "Failed to parse property value.");
        return QVariant();
    }

    if (qObject == NULL || metaObject == NULL)
    {
        error(
            JsonLoader::StringValueParserError, 
            QString("Failed to get object/metaObject for object from string: %1")
            .arg(valueString)
            );
        return QVariant();
    }

    int propertyIndex = metaObject->indexOfProperty(contentName.toLatin1().constData());
    if (propertyIndex < 0) 
    {
        error(
            JsonLoader::StringValueParserError, 
            QString("Failed to convert property string:%1 to meta-property.")
            .arg(valueString)
            );

        return false;
    }

    QMetaProperty property = metaObject->property(propertyIndex);
    PropertyContext result;
    result.setQObject(qObject);
    result.setMetaProperty(property);
    return QVariant::fromValue<PropertyContext>(result);
}


QVariant MethodNameStringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    QObject* qObject = NULL;
    const QMetaObject* metaObject = NULL;
    QString contentName;

    if (!parseObjectAndContents(objectContext, valueString, qObject, metaObject, contentName))
    {
        error(JsonLoader::StringValueParserError, "Failed to parse method value.");
        return QVariant();
    }

    if (qObject == NULL || metaObject == NULL)
    {
        error(
            JsonLoader::StringValueParserError, 
            QString("Failed to get object/metaObject for object from string: %1")
            .arg(valueString)
            );
        return false;
    }

    ObjectContext tmpObjectContext;
    tmpObjectContext.setQObject(qObject);
    QList<QMetaMethod> methods = tmpObjectContext.methods(contentName);
    if (!methods.isEmpty())
    {
        MethodContext result;
        result.setQObject(qObject);
        result.setMetaMethods(methods);
        return QVariant::fromValue<MethodContext>(result);
    }

    error(
        JsonLoader::StringValueParserError, 
        QString("Failed to convert signal/slot string:%1 to meta-method.")
        .arg(valueString)
        );

    return QVariant();
}


QVariant PixmapStringValueParser::parse( ObjectContext* objectContext, const QString& valueString, const QStringList& tags ) const
{
    QPixmap pixmap(valueString);
    return QVariant(pixmap);
}

QVariant SizeStringValueParser::parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const
{
    QString     value  = valueString.toLower();
    QStringList values = value.split(QLatin1Char('x'));
    if (values.size() == 2) 
    {
        int width, height;
        bool widthOk = false, heightOk = false;

        width = values[0].toInt(&widthOk);
        height = values[1].toInt(&heightOk);
        if (widthOk && heightOk)
        {
            return QVariant(QSize(width, height));
        }
    }

    error(
        JsonLoader::StringValueParserError,
        QString("Failed to parse string %1 as QSize.").arg(valueString)
        );
    return QVariant();
}

QVariant RectStringValueParser::parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const
{
    QString     value  = valueString.toLower();
    QStringList values = value.split(QLatin1Char(','));
    if (values.size() == 3) 
    {
        QStringList sizeValue = values[2].split(QLatin1Char('x'));

        int x, y, width, height;
        bool xOk = false, yOk = false, widthOk = false, heightOk = false;

        x = values[0].toInt(&xOk);
        y = values[1].toInt(&yOk);
        width = sizeValue[0].toInt(&widthOk);
        height = sizeValue[1].toInt(&heightOk);
        if (widthOk && heightOk)
        {
            return QVariant(QRect(x, y, width, height));
        }
    }

    error(
        JsonLoader::StringValueParserError,
        QString("Failed to parse string %1 as QRect.").arg(valueString)
        );
    return QVariant();
}

QVariant DateTimeStringValueParser::parse(ObjectContext* objectContext, const QString& valueString, const QStringList& tags) const
{
    QDateTime result;

    // 一般可以由QVariant自动完成转换，调用了此处的自定义Parser说明格式不标准：
    // 使用ISO标准格式，注意时间前面带有T字符，另外毫秒与秒间要使用.而不是:
    error(
        JsonLoader::StringValueParserError,
        QString(
            "Failed to parse string %1 as QDateTime in ISO format, "
            "you can write time string as: yyyy-mm-ddTHH:MM:SS.mmm").arg(valueString)
        );

    bool dateOnly = tags.contains("date");
    bool timeOnly = tags.contains("time");
    if (dateOnly)
    {
        error(
            JsonLoader::UnsupportedFeature,
            QString("Failed to parse string %1 as QDate.").arg(valueString)
            );
    }
    else if (timeOnly)
    {
        error(
            JsonLoader::UnsupportedFeature,
            QString("Failed to parse string %1 as QTime.").arg(valueString)
            );
    }
    else
    {
        
    }

    result = QDateTime::fromString(valueString, Qt::TextDate);

    // QDateTime可以自动转换为QDate和QTime,因此这里一律解析为QDateTime
    return result;
}

/*********************************************************************************************************
** End of file
*********************************************************************************************************/